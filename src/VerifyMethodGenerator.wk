import WakeClass;
import WakeType;
import WakeProperty;
import File;
import ArgumentWatcherGatherer;
import MethodBodyGenerator;

every VerifyMethodGenerator (capable MethodBodyGenerator) is:

	generate(File, WakeClass, WakeProperty, ArgumentWatcherGatherer, WakeType? returntype) {
		#>
		if(ArgumentWatcherGatherer.aliases.getSize() > 0) {
			for(var Num = 0; Num < ArgumentWatcherGatherer.aliases.getSize(); Num += 1) { // @TODO foreach in at
				File.write("\t\t" + ArgumentWatcherGatherer.aliases[Num] + ".tell(arg" + Num.toString() + ", MockTracker.current());\n");
				if returntype exists {
					File.write("\t\t");
					if(Num == 0) {
						File.write("var ReturnValueStubber{" + returntype.getPureName() + "}[] = ");
						File.write(ArgumentWatcherGatherer.aliases[Num] + ".getPossibleStubs(arg0);");
					} else {
						File.write("ReturnValueStubber[] = ReturnValueStubber[].intersect(" + ArgumentWatcherGatherer.aliases[Num] + ".getPossibleStubs(arg" + Num.toString() + "));");
					}
					File.write("\n");
				}
			}

			File.write('\t\tMockTracker.next();\n');

			if returntype exists {
				File.write("\t\treturn ReturnValueStubber[0].get();\n");
			}
		} else {
			File.write('\t\tMockTracker.next();\n');

			if returntype exists {
				File.write("\t\treturn " + (NameTransformer <- this).methodToProperty(WakeProperty.name) + ".get();\n");
			}
		}
		##
	}
