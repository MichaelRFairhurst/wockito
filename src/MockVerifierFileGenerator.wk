import File;
import WakeClass;
import WakeType;
import NameTransformer;
import Map;
import VerifyMethodGenerator;
import ArgumentIterator;
import MethodIterator;
import MethodIteration;
import ImportIterator;
import ArgumentIteration;
import ArgumentWatcherGatherer;
import WhenGatherer;
import MethodBodyGenerator;
import MethodGenerator;
import MethodReturnGenerator;
import VerifyMethodReturnGenerator;
import CommaStatementGenerator;

#>
# Generates files along the lines of:
#
# every ExampleMockVerifier is:
#
# 	needs ArgumentWatcher{Text, Text}:getZpTextZcNumZpZa1 getZpTextZcNumZpZa1, ArgumentWatcher{Num, Text}:getZpTextZcNumZpZa1 getZpTextZcNumZpZa2;
#
#	with public CallValidator? = nothing;
#
#	get(Text, Num) {
#		var Num[] calls = getZpTextZcNumZpZa1.getCallIndices(Text);
#		calls = calls.intersect(getZpTextZcNumZpZa2.getCallIndices(Num));
#		var $CallValidator? = CallValidator; // bugfix.....
#		if $CallValidator exists {
#			$CallValidator.validate(calls);
#		}
#	}
##
every MockVerifierFileGenerator is:

	needs NameTransformer, File, MethodIterator, CommaStatementGenerator;

	provides File <- { return File; },
		MethodGenerator,
		MethodBodyGenerator <- VerifyMethodGenerator, VerifyMethodGenerator,
		MethodReturnGenerator <- VerifyMethodReturnGenerator, VerifyMethodReturnGenerator,
		ArgumentIterator,
		ImportIterator,
		NameTransformer,
		MethodIterator,
		ArgumentWatcherGatherer,
		WhenGatherer;

	generate(WakeClass) {
		generateImports(WakeClass);

		File.write("\n");
		File.write("every " + WakeClass.classname + "Verifier is:\n");

		generateNeeds(WakeClass);
		generateValidatorProperty();
		generateMethods(WakeClass);
	}

	generateValidatorProperty() {
		File.write("\twith public CallValidator? = nothing;\n\n");
	}

	generateImports(WakeClass) {
		var ImportIterator <- this;

		ImportIterator.addImport('When');
		ImportIterator.addImport('ArgumentWatcher');
		ImportIterator.addImport('CallValidator');
		ImportIterator.addImport(WakeClass.classname);

		MethodIterator.set((cast MethodIteration) ImportIterator);
		MethodIterator.iterate(WakeClass);

		foreach(ImportIterator.getImports()) { // @TODO foreach as
			File.write("import " + Text + ";\n");
		}
	}

	generateMethods(WakeClass) {
		MethodIterator.set((cast MethodIteration) (MethodGenerator <- this));
		MethodIterator.iterate(WakeClass);
	}

	generateNeeds(WakeClass) {
		var ArgumentWatcherGatherer <- this;
		MethodIterator.set((cast MethodIteration) ArgumentWatcherGatherer);
		MethodIterator.iterate(WakeClass);

		var Text[] deps = [];

		var Text[] = ArgumentWatcherGatherer.provisions;
		for(var Num = 0; Num < ArgumentWatcherGatherer.provisions.getSize(); Num += 1) {
			deps.push(ArgumentWatcherGatherer.provisions[Num] + " " + ArgumentWatcherGatherer.aliases[Num]);
		}

		var WhenGatherer <- this;
		MethodIterator.set((cast MethodIteration) WhenGatherer);
		MethodIterator.iterate(WakeClass);

		Text[] = WhenGatherer.provisions;
		for(var Num = 0; Num < WhenGatherer.provisions.getSize(); Num += 1) {
			deps.push(WhenGatherer.provisions[Num] + " " + WhenGatherer.aliases[Num]);
		}

		File.write(CommaStatementGenerator.generate("needs", deps));
	}
